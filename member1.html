<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Traffic Management · CityPlan Project</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>

    :root {
      --bg: #ffffff;
      --card: #f3f4f6;
      --border: #d1d5db;
      --text: #1f2937;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-light: #dbeafe;
      --shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
      --radius: 16px;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
    }

    header {
      position: sticky;
      top: 0;
      background: white;
      border-bottom: 1px solid var(--border);
      box-shadow: 0 2px 12px rgba(0,0,0,0.04);
      z-index: 100;
    }

    .nav-inner {
      max-width: 1100px;
      margin: auto;
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    nav a {
      margin-left: 1rem;
      color: var(--muted);
      text-decoration: none;
      font-size: 0.9rem;
      padding: 0.35rem 0.45rem;
      border-radius: 6px;
    }

    nav a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }

    main {
      max-width: 1100px;
      margin: auto;
      padding: 1.5rem;
    }

    section {
      background: var(--card);
      border: 1px solid var(--border);
      padding: 1.5rem;
      border-radius: var(--radius);
      margin-bottom: 2rem;
      box-shadow: var(--shadow);
    }

    h2 {
      margin-top: 0;
      color: var(--accent);
    }

    pre {
      background: #eef2ff;
      padding: 1rem;
      border-radius: 12px;
      overflow-x: auto;
    }

    .chip {
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      background: var(--accent-light);
      color: var(--accent);
      font-size: 0.8rem;
      margin-right: 0.4rem;
    }

    ul { padding-left: 1.2rem; }

  </style>
</head>

<body>

<header>
  <div class="nav-inner">
    <div><strong>Traffic Management · CityPlan</strong></div>
    <nav>
      <a href="#overview">Overview</a>
      <a href="#routing">Routing</a>
      <a href="#signals">Signals</a>
      <a href="#incidents">Incidents</a>
      <a href="#sensors">Sensors</a>
      <a href="#data">Data</a>
      <a href="#code">Code Lab</a>
    </nav>
  </div>
</header>

<main>

<!-- HERO -->
<section>
  <h2>Traffic Management – A Modern Algorithmic Approach</h2>
  <p>
    Traffic management is one of the most important responsibilities of any growing city. As population and vehicle count increase,
    traditional static traffic planning becomes ineffective. This project applies the principles of 
    <strong>Data Structures and Algorithms (DSA)</strong> to analyze, model, and improve the traffic flow in an urban setting.
  </p>
  <p>
    We convert the city into a graph, signals into scheduling units, and vehicles into dynamic data that flow between nodes.
    Using this model, we explore routing algorithms, sensor placement, congestion analysis, accident handling,
    and real-time adjustments to traffic behavior.
  </p>
</section>

<!-- OVERVIEW -->
<section id="overview">
  <h2>1. Project Overview</h2>
  <p>
    Traffic today is no longer just a "road problem." It is a combination of behavioural patterns, infrastructure limitations,
    route decisions, signal timings, and unexpected events like roadblocks or accidents.
  </p>
  <p>
    To understand this system scientifically, we collected sample data from five major junctions such as waiting times,
    vehicle count, lane behavior, pedestrian movements, and bottleneck points. Using this data as reference,
    we developed an algorithm-first strategy to fix common pain points.
  </p>

  <div>
    <span class="chip">Graphs</span>
    <span class="chip">Shortest Path</span>
    <span class="chip">Queue Simulation</span>
    <span class="chip">Greedy Scheduling</span>
    <span class="chip">MST</span>
    <span class="chip">Sorting Algorithms</span>
  </div>

  <p>
    This helps us form a complete picture of how traffic behaves and how we can optimize its flow using minimal resources.
  </p>
</section>

<!-- ROUTING -->
<section id="routing">
  <h2>2. Smart Vehicle Routing</h2>
  <p>
    Routing is the backbone of any traffic system. When too many vehicles choose the same path, congestion becomes unavoidable.
    To prevent this, route planning algorithms are used to suggest efficient roads based on current traffic load, distance,
    and speed limits.
  </p>

  <h3>How We Model Routing</h3>
  <ul>
    <li><strong>Nodes</strong> represent intersections.</li>
    <li><strong>Edges</strong> represent connecting roads.</li>
    <li><strong>Weights</strong> represent travel time, distance, or traffic density.</li>
  </ul>

  <p>
    Based on this representation, we use <strong>Dijkstra’s Algorithm</strong> to find the fastest route.
    This approach is used by navigation apps like Google Maps.
  </p>

  <h3>Algorithm Pseudocode</h3>
  <pre>
function Dijkstra(graph, source):
    for each node:
        dist[node] = INF
    dist[source] = 0
    PQ.push(source, 0)

    while PQ is not empty:
        node = PQ.extractMin()
        for each neighbor of node:
            if dist[node] + weight < dist[neighbor]:
                dist[neighbor] = dist[node] + weight
                PQ.push(neighbor, dist[neighbor])
  </pre>

  <p>
    This allows dynamic re-routing during accidents, peak hours, or road closures. It reduces traffic pressure
    on over-utilized paths and intelligently distributes vehicles across parallel routes.
  </p>
</section>

<!-- SIGNALS -->
<section id="signals">
  <h2>3. Adaptive Traffic Signal Control</h2>
  <p>
    Traditional signals operate in a fixed time cycle. However, traffic is not constant. Some directions carry heavier load,
    while others are nearly empty. Giving equal time to all directions causes unnecessary waiting.
  </p>

  <h3>Our Adaptive Approach</h3>
  <p>
    We calculate green light duration based on vehicle count and distribute the total cycle time proportionally.
    This saves time and reduces fuel consumption.
  </p>

  <h3>Green Time Pseudocode</h3>
  <pre>
function allocateGreenTime(count[], cycleTime):
    total = sum(count)
    for each direction:
        green[i] = (count[i] / total) * cycleTime
    return green
  </pre>

  <p>
    During peak hours, this system automatically prioritizes real traffic demand instead of using a fixed-template signal pattern.
    It also lowers the chance of long queues and gridlocks.
  </p>
</section>

<!-- INCIDENTS -->
<section id="incidents">
  <h2>4. Accident Handling & Road Block Management</h2>
  <p>
    One of the biggest challenges in traffic management is dealing with unexpected incidents like breakdowns,
    construction work, and collisions. These events disrupt normal traffic flow and may isolate parts of the network.
  </p>

  <h3>How We Detect Network Disruption</h3>
  <ul>
    <li>We remove the blocked edge (road) temporarily from the graph.</li>
    <li>Run DFS/BFS to check if all nodes remain connected.</li>
    <li>If not connected, alternative routes are suggested using shortest path algorithms.</li>
  </ul>

  <h3>Connectivity Check</h3>
  <pre>
function DFS(node):
    mark node visited
    for neighbor in adj[node]:
        if not visited[neighbor]:
            DFS(neighbor)
  </pre>

  <p>
    This method helps us quickly detect isolated regions and reroute vehicles intelligently.
  </p>
</section>

<!-- SENSORS -->
<section id="sensors">
  <h2>5. Sensor & CCTV Placement Using Minimum Spanning Tree</h2>
  <p>
    To efficiently monitor traffic, cities deploy sensors and CCTV cameras at strategic points.
    Instead of connecting every camera individually, we use an MST algorithm to minimize wiring or communication cost.
  </p>

  <h3>Why MST?</h3>
  <ul>
    <li>Ensures all sensor nodes are reachable</li>
    <li>Reduces installation cost</li>
    <li>Maintains efficient monitoring network</li>
  </ul>

  <h3>Pseudocode for Prim’s MST</h3>
  <pre>
function Prim(graph, start):
    cost[] = INF
    cost[start] = 0
    while not all vertices visited:
        u = vertex with minimum cost
        add u to MST
        update cost[] of neighbors
  </pre>
</section>

<!-- DATA -->
<section id="data">
  <h2>6. Traffic Data Analysis & Sorting</h2>
  <p>
    Traffic data is constantly generated from sensors, ANPR cameras, and patrol reports.
    To interpret this data meaningfully, we use sorting algorithms to identify pattern behavior such as
    peak hours, busiest junctions, and unpredictable spikes.
  </p>

  <h3>How Sorting Helps</h3>
  <ul>
    <li>Merge Sort groups data chronologically</li>
    <li>Quick Sort speeds up dashboard refresh rates</li>
    <li>Sorting enables top-10 congested roads lists</li>
    <li>Helps compare before/after traffic optimization</li>
  </ul>

  <pre>
function mergeSort(a[], left, right):
    if left >= right:
        return
    mid = (left + right) / 2
    mergeSort(a, left, mid)
    mergeSort(a, mid+1, right)
    merge(a, left, mid, right)
  </pre>

  <p>
    With sorted data, traffic teams can easily identify improvement trends and problematic locations.
  </p>
</section>

<!-- CODE LAB -->
<section id="code">
  <h2>7. Code Lab – Traffic Simulation Snippets</h2>
  <p>
    Below programs demonstrate miniature versions of real traffic behavior. These help in understanding queues,
    congestion buildup, and the importance of optimized green signals.
  </p>

  <h3>C Program: Junction Queue Simulation</h3>
  <pre>
#include &lt;stdio.h&gt;

int main() {
    int queue = 0, arrivals, departures;

    for(int i=1;i<=5;i++){
        printf("Cycle %d\n", i);
        printf("Vehicles arrived: ");
        scanf("%d", &arrivals);
        printf("Vehicles passed: ");
        scanf("%d", &departures);

        queue = queue + arrivals - departures;
        if(queue < 0) queue = 0;

        printf("Vehicles waiting now: %d\n\n", queue);
    }
    return 0;
}
  </pre>
</section>

</main>

</body>
</html>
